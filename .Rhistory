#make a dataframe with the precise info for each SNP for this chromosome
chrom.df<-data.frame(CHROM=rep(t, times=length(fix.sub)), POS=fix.sub, keep=k)
#now we rbind in the information for this chromosome to the overall df
keep.df<-rbind(keep.df,chrom.df)
#empty df for this chrom to prepare for the next one
chrom.df<-NULL
#update progress bar
utils::setTxtProgressBar(pb, pbtrack)
#update tracker
pbtrack<-pbtrack+1
} #close for loop, start over on next chromosome
#close progress bar
close(pb)
#order the dataframe to match the order of the input vcf file
#remove scientific notation
keep.df$POS<-format(keep.df$POS,scientific = FALSE)
df$POS<-format(df$POS,scientific = FALSE)
#make sure class matches between the columns you're trying to merge
keep.df$POS<-as.numeric(as.character(keep.df$POS))
df$POS<-as.numeric(as.character(df$POS))
#make sure class matches between the columns you're trying to merge
keep.df$CHROM<-as.character(keep.df$CHROM)
df$CHROM<-as.character(df$CHROM)
#add tracking column
df$id<-c(1:nrow(df))
#merge
order.df<-merge(keep.df,df)
#order based on tracking column
order.df<-order.df[order(order.df$id),]
View(order.df)
vcfR<-read.vcfR("~/Downloads/hippo.wgs/chr.18.subset.recode.vcf.gz")
#set min distance specified by user
j=100
#generate dataframe containing information for chromosome and bp locality of each SNP
df<-as.data.frame(vcfR@fix[,1:2])
#generate list of all unique chromosomes in alphabetical order
chroms<-levels(as.factor(df$CHROM))
#intialize empty df to hold filtering
keep.df<-data.frame()
#make progress bar
pb <- utils::txtProgressBar(min = 0, max = length(chroms), style = 3)
#begin tracker
pbtrack<-1
#loop over each chromosome
#for t in vector containing the name of each chromosome
for (t in chroms){
#isolate the SNP positions on the given chromosome
fix.sub<-as.numeric(df$POS[df$CHROM == t])
#order the positions numerically
fix.sub<-fix.sub[order(fix.sub)]
#set the first position
prev<-fix.sub[1]
#initialize empty vector
k<-c()
#always keep first SNP on the chromosome
k[1]<-TRUE
#loop to decide whether to keep each following SNP
if (length(fix.sub) < 2){
#if chrom only has 1 SNP, do nothing
} else{
#else, use a for loop to determine which SNPs to keep that satisfy our distance criteria
for (i in 2:length(fix.sub)){
#store logical indicating whether this SNP is greater than j base pairs from the previous SNP
k[i]<- fix.sub[i] > prev+j
#if it is, then we keep this SNP, making it the new 'previous' for assessing the next point.
#If we don't keep the SNP, we don't update the closest point
if (fix.sub[i] > prev+j){
prev<-fix.sub[i]
}
#close for loop
}
#close else statement
}
#make a dataframe with the precise info for each SNP for this chromosome
chrom.df<-data.frame(CHROM=rep(t, times=length(fix.sub)), POS=fix.sub, keep=k)
#now we rbind in the information for this chromosome to the overall df
keep.df<-rbind(keep.df,chrom.df)
#empty df for this chrom to prepare for the next one
chrom.df<-NULL
#update progress bar
utils::setTxtProgressBar(pb, pbtrack)
#update tracker
pbtrack<-pbtrack+1
} #close for loop, start over on next chromosome
#close progress bar
close(pb)
#order the dataframe to match the order of the input vcf file
#remove scientific notation
keep.df$POS<-format(keep.df$POS,scientific = FALSE)
df$POS<-format(df$POS,scientific = FALSE)
#make sure class matches between the columns you're trying to merge
keep.df$POS<-as.numeric(as.character(keep.df$POS))
df$POS<-as.numeric(as.character(df$POS))
#make sure class matches between the columns you're trying to merge
keep.df$CHROM<-as.character(keep.df$CHROM)
df$CHROM<-as.character(df$CHROM)
#add tracking column
df$id<-c(1:nrow(df))
#merge
order.df<-merge(keep.df,df)
#order based on tracking column
order.df<-order.df[order(order.df$id),]
View(order.df)
rhub::check_for_cran()
DeRaad, D.A. (2022), SNPfiltR: an R package for interactive and reproducible SNP filtering. Mol Ecol Resour. Accepted Author Manuscript. https://doi.org/10.1111/1755-0998.13618
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
distance_thin(vcfR = read.vcfR("~/Desktop/benchmarking.vcfs/benchmark.10K.vcf.gz")
#set min distance specified by user
j=100
#generate dataframe containing information for chromosome and bp locality of each SNP
df<-as.data.frame(vcfR@fix[,1:2])
#generate list of all unique chromosomes in alphabetical order
chroms<-levels(as.factor(df$CHROM))
#intialize empty df to hold filtering
keep.df<-data.frame()
#make progress bar
pb <- utils::txtProgressBar(min = 0, max = length(chroms), style = 3)
#begin tracker
pbtrack<-1
#loop over each chromosome
#for t in vector containing the name of each chromosome
for (t in chroms){
#isolate the SNP positions on the given chromosome
fix.sub<-as.numeric(df$POS[df$CHROM == t])
#order the positions numerically
fix.sub<-fix.sub[order(fix.sub)]
#set the first position
prev<-fix.sub[1]
#initialize empty vector
k<-c()
#always keep first SNP on the chromosome
k[1]<-TRUE
#loop to decide whether to keep each following SNP
if (length(fix.sub) < 2){
#if chrom only has 1 SNP, do nothing
} else{
#else, use a for loop to determine which SNPs to keep that satisfy our distance criteria
for (i in 2:length(fix.sub)){
#store logical indicating whether this SNP is greater than j base pairs from the previous SNP
k[i]<- fix.sub[i] > prev+j
#if it is, then we keep this SNP, making it the new 'previous' for assessing the next point.
#If we don't keep the SNP, we don't update the closest point
if (fix.sub[i] > prev+j){
prev<-fix.sub[i]
}
#close for loop
}
#close else statement
}
#make a dataframe with the precise info for each SNP for this chromosome
chrom.df<-data.frame(CHROM=rep(t, times=length(fix.sub)), POS=fix.sub, keep=k)
#now we rbind in the information for this chromosome to the overall df
keep.df<-rbind(keep.df,chrom.df)
#empty df for this chrom to prepare for the next one
chrom.df<-NULL
#update progress bar
utils::setTxtProgressBar(pb, pbtrack)
#update tracker
pbtrack<-pbtrack+1
} #close for loop, start over on next chromosome
#close progress bar
close(pb)
#order the dataframe to match the order of the input vcf file
#remove scientific notation
keep.df$POS<-format(keep.df$POS,scientific = FALSE)
df$POS<-format(df$POS,scientific = FALSE)
#make sure class matches between the columns you're trying to merge
keep.df$POS<-as.numeric(as.character(keep.df$POS))
df$POS<-as.numeric(as.character(df$POS))
#make sure class matches between the columns you're trying to merge
keep.df$CHROM<-as.character(keep.df$CHROM)
df$CHROM<-as.character(df$CHROM)
#add tracking column
df$id<-c(1:nrow(df))
#merge
order.df<-merge(keep.df,df)
#order based on tracking column
order.df<-order.df[order(order.df$id),]
#order.df<-keep.df[match(paste(df$CHROM,format(df$POS,scientific = FALSE)), paste(keep.df$CHROM,format(keep.df$POS,scientific = FALSE))),]
#note: the position vector must be stripped of scientific notation otherwise identical numbers will not be recognized as matches, giving NA values
#note: this old approach using match() has been deprecated because there were too many formatting issues causing
#match to not be able to correctly match the order between 'df' and 'keep.df'. Now we use merge() which seems to be more robust
#write a test to catch if this internal dataset is not able to merge correctly
if (sum(is.na(order.df)) > .5){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
#write a test to catch if this internal dataset is not able to merge correctly
if (order.df$id != c(1:nrow(df))){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
#subset vcfR locus info based on the logical column from our dataframe
#vcfR@fix<-vcfR@fix[order.df$keep,]
#subset genotypes based on logical
#vcfR@gt<-vcfR@gt[order.df$keep,]
#realized there is no need to do this subsetting separately
vcfR<-vcfR[order.df$keep,]
#calculate number of total SNPs input
z<-nrow(keep.df)
#calculate total SNPs retained
p<-nrow(vcfR@fix)
#print info to screen
message(p," out of ",z," input SNPs were not located within ",j," base-pairs of another SNP and were retained despite filtering")
#return vcfR
return(vcfR)
}
distance_thin(vcfR = read.vcfR("~/Desktop/benchmarking.vcfs/benchmark.10K.vcf.gz")
)
distance_thin(vcfR = read.vcfR("~/Desktop/benchmarking.vcfs/benchmark.10K.vcf.gz"), min.distance = 100)
vcfR = read.vcfR("~/Desktop/benchmarking.vcfs/benchmark.10K.vcf.gz")
j=100
#generate dataframe containing information for chromosome and bp locality of each SNP
df<-as.data.frame(vcfR@fix[,1:2])
#generate list of all unique chromosomes in alphabetical order
chroms<-levels(as.factor(df$CHROM))
#intialize empty df to hold filtering
keep.df<-data.frame()
#make progress bar
pb <- utils::txtProgressBar(min = 0, max = length(chroms), style = 3)
#begin tracker
pbtrack<-1
#loop over each chromosome
#for t in vector containing the name of each chromosome
for (t in chroms){
#isolate the SNP positions on the given chromosome
fix.sub<-as.numeric(df$POS[df$CHROM == t])
#order the positions numerically
fix.sub<-fix.sub[order(fix.sub)]
#set the first position
prev<-fix.sub[1]
#initialize empty vector
k<-c()
#always keep first SNP on the chromosome
k[1]<-TRUE
#loop to decide whether to keep each following SNP
if (length(fix.sub) < 2){
#if chrom only has 1 SNP, do nothing
} else{
#else, use a for loop to determine which SNPs to keep that satisfy our distance criteria
for (i in 2:length(fix.sub)){
#store logical indicating whether this SNP is greater than j base pairs from the previous SNP
k[i]<- fix.sub[i] > prev+j
#if it is, then we keep this SNP, making it the new 'previous' for assessing the next point.
#If we don't keep the SNP, we don't update the closest point
if (fix.sub[i] > prev+j){
prev<-fix.sub[i]
}
#close for loop
}
#close else statement
}
#make a dataframe with the precise info for each SNP for this chromosome
chrom.df<-data.frame(CHROM=rep(t, times=length(fix.sub)), POS=fix.sub, keep=k)
#now we rbind in the information for this chromosome to the overall df
keep.df<-rbind(keep.df,chrom.df)
#empty df for this chrom to prepare for the next one
chrom.df<-NULL
#update progress bar
utils::setTxtProgressBar(pb, pbtrack)
#update tracker
pbtrack<-pbtrack+1
} #close for loop, start over on next chromosome
#close progress bar
close(pb)
#order the dataframe to match the order of the input vcf file
#remove scientific notation
keep.df$POS<-format(keep.df$POS,scientific = FALSE)
df$POS<-format(df$POS,scientific = FALSE)
#make sure class matches between the columns you're trying to merge
keep.df$POS<-as.numeric(as.character(keep.df$POS))
df$POS<-as.numeric(as.character(df$POS))
#make sure class matches between the columns you're trying to merge
keep.df$CHROM<-as.character(keep.df$CHROM)
df$CHROM<-as.character(df$CHROM)
#add tracking column
df$id<-c(1:nrow(df))
#merge
order.df<-merge(keep.df,df)
#order based on tracking column
order.df<-order.df[order(order.df$id),]
View(df)
View(keep.df)
View(order.df)
tail(order.df)
order.df<-merge(keep.df,df)
length(unique(paste(order.df$CHROM,order.df$POS)))
length(unique(paste(df$CHROM,df$POS)))
df<-as.data.frame(vcfR@fix[,1:2])
length(unique(paste(df$CHROM,df$POS)))
View(df)
vcfR
length(unique(paste(df$CHROM,df$POS)))
message(nrow(df) - length(unique(paste(df$CHROM,df$POS)))," duplicated SNPs in input vcf")
duplicated(paste(df$CHROM,df$POS))
table(duplicated(paste(df$CHROM,df$POS)))
table(!duplicated(paste(df$CHROM,df$POS)))
vcfR<-vcfR[!duplicated(paste(df$CHROM,df$POS)),]
vcfR
vcfR = read.vcfR("~/Desktop/benchmarking.vcfs/benchmark.10K.vcf.gz")
#set min distance specified by user
j=100
#generate dataframe containing information for chromosome and bp locality of each SNP
df<-as.data.frame(vcfR@fix[,1:2])
#write test to identify and remove duplicated SNPs in input vcf
if (length(unique(paste(df$CHROM,df$POS))) < nrow(df)){
#remove duplicated SNPs
vcfR<-vcfR[!duplicated(paste(df$CHROM,df$POS)),]
#regenerate df without duplicate inputs
df<-as.data.frame(vcfR@fix[,1:2])
#report to user
message(nrow(df) - length(unique(paste(df$CHROM,df$POS)))," duplicated SNPs removed from input vcf")
}
length(unique(paste(df$CHROM,df$POS)))
#generate list of all unique chromosomes in alphabetical order
chroms<-levels(as.factor(df$CHROM))
#intialize empty df to hold filtering
keep.df<-data.frame()
#make progress bar
pb <- utils::txtProgressBar(min = 0, max = length(chroms), style = 3)
#begin tracker
pbtrack<-1
vcfR = read.vcfR("~/Desktop/benchmarking.vcfs/benchmark.10K.vcf.gz")
#set min distance specified by user
j=100
#generate dataframe containing information for chromosome and bp locality of each SNP
df<-as.data.frame(vcfR@fix[,1:2])
#write test to identify and remove duplicated SNPs in input vcf
if (length(unique(paste(df$CHROM,df$POS))) < nrow(df)){
#remove duplicated SNPs
vcfR<-vcfR[!duplicated(paste(df$CHROM,df$POS)),]
#report to user
message(nrow(df) - length(unique(paste(df$CHROM,df$POS)))," duplicated SNPs removed from input vcf")
#regenerate df without duplicate inputs
df<-as.data.frame(vcfR@fix[,1:2])
}
length(unique(paste(df$CHROM,df$POS)))
#generate list of all unique chromosomes in alphabetical order
chroms<-levels(as.factor(df$CHROM))
#intialize empty df to hold filtering
keep.df<-data.frame()
#make progress bar
pb <- utils::txtProgressBar(min = 0, max = length(chroms), style = 3)
#begin tracker
pbtrack<-1
for (t in chroms){
#isolate the SNP positions on the given chromosome
fix.sub<-as.numeric(df$POS[df$CHROM == t])
#order the positions numerically
fix.sub<-fix.sub[order(fix.sub)]
#set the first position
prev<-fix.sub[1]
#initialize empty vector
k<-c()
#always keep first SNP on the chromosome
k[1]<-TRUE
#loop to decide whether to keep each following SNP
if (length(fix.sub) < 2){
#if chrom only has 1 SNP, do nothing
} else{
#else, use a for loop to determine which SNPs to keep that satisfy our distance criteria
for (i in 2:length(fix.sub)){
#store logical indicating whether this SNP is greater than j base pairs from the previous SNP
k[i]<- fix.sub[i] > prev+j
#if it is, then we keep this SNP, making it the new 'previous' for assessing the next point.
#If we don't keep the SNP, we don't update the closest point
if (fix.sub[i] > prev+j){
prev<-fix.sub[i]
}
#close for loop
}
#close else statement
}
#make a dataframe with the precise info for each SNP for this chromosome
chrom.df<-data.frame(CHROM=rep(t, times=length(fix.sub)), POS=fix.sub, keep=k)
#now we rbind in the information for this chromosome to the overall df
keep.df<-rbind(keep.df,chrom.df)
#empty df for this chrom to prepare for the next one
chrom.df<-NULL
#update progress bar
utils::setTxtProgressBar(pb, pbtrack)
#update tracker
pbtrack<-pbtrack+1
} #close for loop, start over on next chromosome
#close progress bar
close(pb)
#order the dataframe to match the order of the input vcf file
#remove scientific notation
keep.df$POS<-format(keep.df$POS,scientific = FALSE)
df$POS<-format(df$POS,scientific = FALSE)
#make sure class matches between the columns you're trying to merge
keep.df$POS<-as.numeric(as.character(keep.df$POS))
df$POS<-as.numeric(as.character(df$POS))
#make sure class matches between the columns you're trying to merge
keep.df$CHROM<-as.character(keep.df$CHROM)
df$CHROM<-as.character(df$CHROM)
#add tracking column
df$id<-c(1:nrow(df))
#merge
order.df<-merge(keep.df,df)
#order based on tracking column
order.df<-order.df[order(order.df$id),]
if (sum(is.na(order.df)) > .5){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
#write a test to catch if this internal dataset is not able to merge correctly
if (order.df$id != c(1:nrow(df))){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
View(order.df)
#write a test to catch if this internal dataset is not able to merge correctly
if (sum(order.df$id != c(1:nrow(df))) > .5){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
pkgdown::build_site()
pkgdown::build_home()
pkgdown::build_home()
rhub::check_for_cran()
pkgdown::build_home()
rhub::check_for_cran()
rhub::check_for_cran()
pkgdown::build_home()
pkgdown::build_home()
vcfR<-read.vcfR("~/Downloads/hippo.wgs/chr.18.subset.recode.vcf.gz")
j=100
#generate dataframe containing information for chromosome and bp locality of each SNP
df<-as.data.frame(vcfR@fix[,1:2])
#write test to identify and remove duplicated SNPs in input vcf
if (length(unique(paste(df$CHROM,df$POS))) < nrow(df)){
#remove duplicated SNPs
vcfR<-vcfR[!duplicated(paste(df$CHROM,df$POS)),]
#report to user
message(nrow(df) - length(unique(paste(df$CHROM,df$POS)))," duplicated SNPs removed from input vcf")
#regenerate df without duplicate inputs
df<-as.data.frame(vcfR@fix[,1:2])
}
#generate list of all unique chromosomes in alphabetical order
chroms<-levels(as.factor(df$CHROM))
#intialize empty df to hold filtering
keep.df<-data.frame()
#make progress bar
pb <- utils::txtProgressBar(min = 0, max = length(chroms), style = 3)
#begin tracker
pbtrack<-1
#loop over each chromosome
#for t in vector containing the name of each chromosome
for (t in chroms){
#isolate the SNP positions on the given chromosome
fix.sub<-as.numeric(df$POS[df$CHROM == t])
#order the positions numerically
fix.sub<-fix.sub[order(fix.sub)]
#set the first position
prev<-fix.sub[1]
#initialize empty vector
k<-c()
#always keep first SNP on the chromosome
k[1]<-TRUE
#loop to decide whether to keep each following SNP
if (length(fix.sub) < 2){
#if chrom only has 1 SNP, do nothing
} else{
#else, use a for loop to determine which SNPs to keep that satisfy our distance criteria
for (i in 2:length(fix.sub)){
#store logical indicating whether this SNP is greater than j base pairs from the previous SNP
k[i]<- fix.sub[i] > prev+j
#if it is, then we keep this SNP, making it the new 'previous' for assessing the next point.
#If we don't keep the SNP, we don't update the closest point
if (fix.sub[i] > prev+j){
prev<-fix.sub[i]
}
#close for loop
}
#close else statement
}
#make a dataframe with the precise info for each SNP for this chromosome
chrom.df<-data.frame(CHROM=rep(t, times=length(fix.sub)), POS=fix.sub, keep=k)
#now we rbind in the information for this chromosome to the overall df
keep.df<-rbind(keep.df,chrom.df)
#empty df for this chrom to prepare for the next one
chrom.df<-NULL
#update progress bar
utils::setTxtProgressBar(pb, pbtrack)
#update tracker
pbtrack<-pbtrack+1
} #close for loop, start over on next chromosome
#close progress bar
close(pb)
#order the dataframe to match the order of the input vcf file
#remove scientific notation
keep.df$POS<-format(keep.df$POS,scientific = FALSE)
df$POS<-format(df$POS,scientific = FALSE)
#make sure class matches between the columns you're trying to merge
keep.df$POS<-as.numeric(as.character(keep.df$POS))
df$POS<-as.numeric(as.character(df$POS))
#make sure class matches between the columns you're trying to merge
keep.df$CHROM<-as.character(keep.df$CHROM)
df$CHROM<-as.character(df$CHROM)
#add tracking column
df$id<-c(1:nrow(df))
#merge
order.df<-merge(keep.df,df)
#order based on tracking column
order.df<-order.df[order(order.df$id),]
View(order.df)
#write a test to catch if this internal dataset is not able to merge correctly
if (sum(is.na(order.df)) > .5){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
#write a test to catch if this internal dataset is not able to merge correctly
if (sum(order.df$id != c(1:nrow(df))) > .5){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
