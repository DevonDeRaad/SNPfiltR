df$id<-c(1:nrow(df))
#merge
order.df<-merge(keep.df,df)
#order based on tracking column
order.df<-order.df[order(order.df$id),]
View(order.df)
rhub::check_for_cran()
DeRaad, D.A. (2022), SNPfiltR: an R package for interactive and reproducible SNP filtering. Mol Ecol Resour. Accepted Author Manuscript. https://doi.org/10.1111/1755-0998.13618
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
distance_thin(vcfR = read.vcfR("~/Desktop/benchmarking.vcfs/benchmark.10K.vcf.gz")
#set min distance specified by user
j=100
#generate dataframe containing information for chromosome and bp locality of each SNP
df<-as.data.frame(vcfR@fix[,1:2])
#generate list of all unique chromosomes in alphabetical order
chroms<-levels(as.factor(df$CHROM))
#intialize empty df to hold filtering
keep.df<-data.frame()
#make progress bar
pb <- utils::txtProgressBar(min = 0, max = length(chroms), style = 3)
#begin tracker
pbtrack<-1
#loop over each chromosome
#for t in vector containing the name of each chromosome
for (t in chroms){
#isolate the SNP positions on the given chromosome
fix.sub<-as.numeric(df$POS[df$CHROM == t])
#order the positions numerically
fix.sub<-fix.sub[order(fix.sub)]
#set the first position
prev<-fix.sub[1]
#initialize empty vector
k<-c()
#always keep first SNP on the chromosome
k[1]<-TRUE
#loop to decide whether to keep each following SNP
if (length(fix.sub) < 2){
#if chrom only has 1 SNP, do nothing
} else{
#else, use a for loop to determine which SNPs to keep that satisfy our distance criteria
for (i in 2:length(fix.sub)){
#store logical indicating whether this SNP is greater than j base pairs from the previous SNP
k[i]<- fix.sub[i] > prev+j
#if it is, then we keep this SNP, making it the new 'previous' for assessing the next point.
#If we don't keep the SNP, we don't update the closest point
if (fix.sub[i] > prev+j){
prev<-fix.sub[i]
}
#close for loop
}
#close else statement
}
#make a dataframe with the precise info for each SNP for this chromosome
chrom.df<-data.frame(CHROM=rep(t, times=length(fix.sub)), POS=fix.sub, keep=k)
#now we rbind in the information for this chromosome to the overall df
keep.df<-rbind(keep.df,chrom.df)
#empty df for this chrom to prepare for the next one
chrom.df<-NULL
#update progress bar
utils::setTxtProgressBar(pb, pbtrack)
#update tracker
pbtrack<-pbtrack+1
} #close for loop, start over on next chromosome
#close progress bar
close(pb)
#order the dataframe to match the order of the input vcf file
#remove scientific notation
keep.df$POS<-format(keep.df$POS,scientific = FALSE)
df$POS<-format(df$POS,scientific = FALSE)
#make sure class matches between the columns you're trying to merge
keep.df$POS<-as.numeric(as.character(keep.df$POS))
df$POS<-as.numeric(as.character(df$POS))
#make sure class matches between the columns you're trying to merge
keep.df$CHROM<-as.character(keep.df$CHROM)
df$CHROM<-as.character(df$CHROM)
#add tracking column
df$id<-c(1:nrow(df))
#merge
order.df<-merge(keep.df,df)
#order based on tracking column
order.df<-order.df[order(order.df$id),]
#order.df<-keep.df[match(paste(df$CHROM,format(df$POS,scientific = FALSE)), paste(keep.df$CHROM,format(keep.df$POS,scientific = FALSE))),]
#note: the position vector must be stripped of scientific notation otherwise identical numbers will not be recognized as matches, giving NA values
#note: this old approach using match() has been deprecated because there were too many formatting issues causing
#match to not be able to correctly match the order between 'df' and 'keep.df'. Now we use merge() which seems to be more robust
#write a test to catch if this internal dataset is not able to merge correctly
if (sum(is.na(order.df)) > .5){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
#write a test to catch if this internal dataset is not able to merge correctly
if (order.df$id != c(1:nrow(df))){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
#subset vcfR locus info based on the logical column from our dataframe
#vcfR@fix<-vcfR@fix[order.df$keep,]
#subset genotypes based on logical
#vcfR@gt<-vcfR@gt[order.df$keep,]
#realized there is no need to do this subsetting separately
vcfR<-vcfR[order.df$keep,]
#calculate number of total SNPs input
z<-nrow(keep.df)
#calculate total SNPs retained
p<-nrow(vcfR@fix)
#print info to screen
message(p," out of ",z," input SNPs were not located within ",j," base-pairs of another SNP and were retained despite filtering")
#return vcfR
return(vcfR)
}
distance_thin(vcfR = read.vcfR("~/Desktop/benchmarking.vcfs/benchmark.10K.vcf.gz")
)
distance_thin(vcfR = read.vcfR("~/Desktop/benchmarking.vcfs/benchmark.10K.vcf.gz"), min.distance = 100)
vcfR = read.vcfR("~/Desktop/benchmarking.vcfs/benchmark.10K.vcf.gz")
j=100
#generate dataframe containing information for chromosome and bp locality of each SNP
df<-as.data.frame(vcfR@fix[,1:2])
#generate list of all unique chromosomes in alphabetical order
chroms<-levels(as.factor(df$CHROM))
#intialize empty df to hold filtering
keep.df<-data.frame()
#make progress bar
pb <- utils::txtProgressBar(min = 0, max = length(chroms), style = 3)
#begin tracker
pbtrack<-1
#loop over each chromosome
#for t in vector containing the name of each chromosome
for (t in chroms){
#isolate the SNP positions on the given chromosome
fix.sub<-as.numeric(df$POS[df$CHROM == t])
#order the positions numerically
fix.sub<-fix.sub[order(fix.sub)]
#set the first position
prev<-fix.sub[1]
#initialize empty vector
k<-c()
#always keep first SNP on the chromosome
k[1]<-TRUE
#loop to decide whether to keep each following SNP
if (length(fix.sub) < 2){
#if chrom only has 1 SNP, do nothing
} else{
#else, use a for loop to determine which SNPs to keep that satisfy our distance criteria
for (i in 2:length(fix.sub)){
#store logical indicating whether this SNP is greater than j base pairs from the previous SNP
k[i]<- fix.sub[i] > prev+j
#if it is, then we keep this SNP, making it the new 'previous' for assessing the next point.
#If we don't keep the SNP, we don't update the closest point
if (fix.sub[i] > prev+j){
prev<-fix.sub[i]
}
#close for loop
}
#close else statement
}
#make a dataframe with the precise info for each SNP for this chromosome
chrom.df<-data.frame(CHROM=rep(t, times=length(fix.sub)), POS=fix.sub, keep=k)
#now we rbind in the information for this chromosome to the overall df
keep.df<-rbind(keep.df,chrom.df)
#empty df for this chrom to prepare for the next one
chrom.df<-NULL
#update progress bar
utils::setTxtProgressBar(pb, pbtrack)
#update tracker
pbtrack<-pbtrack+1
} #close for loop, start over on next chromosome
#close progress bar
close(pb)
#order the dataframe to match the order of the input vcf file
#remove scientific notation
keep.df$POS<-format(keep.df$POS,scientific = FALSE)
df$POS<-format(df$POS,scientific = FALSE)
#make sure class matches between the columns you're trying to merge
keep.df$POS<-as.numeric(as.character(keep.df$POS))
df$POS<-as.numeric(as.character(df$POS))
#make sure class matches between the columns you're trying to merge
keep.df$CHROM<-as.character(keep.df$CHROM)
df$CHROM<-as.character(df$CHROM)
#add tracking column
df$id<-c(1:nrow(df))
#merge
order.df<-merge(keep.df,df)
#order based on tracking column
order.df<-order.df[order(order.df$id),]
View(df)
View(keep.df)
View(order.df)
tail(order.df)
order.df<-merge(keep.df,df)
length(unique(paste(order.df$CHROM,order.df$POS)))
length(unique(paste(df$CHROM,df$POS)))
df<-as.data.frame(vcfR@fix[,1:2])
length(unique(paste(df$CHROM,df$POS)))
View(df)
vcfR
length(unique(paste(df$CHROM,df$POS)))
message(nrow(df) - length(unique(paste(df$CHROM,df$POS)))," duplicated SNPs in input vcf")
duplicated(paste(df$CHROM,df$POS))
table(duplicated(paste(df$CHROM,df$POS)))
table(!duplicated(paste(df$CHROM,df$POS)))
vcfR<-vcfR[!duplicated(paste(df$CHROM,df$POS)),]
vcfR
vcfR = read.vcfR("~/Desktop/benchmarking.vcfs/benchmark.10K.vcf.gz")
#set min distance specified by user
j=100
#generate dataframe containing information for chromosome and bp locality of each SNP
df<-as.data.frame(vcfR@fix[,1:2])
#write test to identify and remove duplicated SNPs in input vcf
if (length(unique(paste(df$CHROM,df$POS))) < nrow(df)){
#remove duplicated SNPs
vcfR<-vcfR[!duplicated(paste(df$CHROM,df$POS)),]
#regenerate df without duplicate inputs
df<-as.data.frame(vcfR@fix[,1:2])
#report to user
message(nrow(df) - length(unique(paste(df$CHROM,df$POS)))," duplicated SNPs removed from input vcf")
}
length(unique(paste(df$CHROM,df$POS)))
#generate list of all unique chromosomes in alphabetical order
chroms<-levels(as.factor(df$CHROM))
#intialize empty df to hold filtering
keep.df<-data.frame()
#make progress bar
pb <- utils::txtProgressBar(min = 0, max = length(chroms), style = 3)
#begin tracker
pbtrack<-1
vcfR = read.vcfR("~/Desktop/benchmarking.vcfs/benchmark.10K.vcf.gz")
#set min distance specified by user
j=100
#generate dataframe containing information for chromosome and bp locality of each SNP
df<-as.data.frame(vcfR@fix[,1:2])
#write test to identify and remove duplicated SNPs in input vcf
if (length(unique(paste(df$CHROM,df$POS))) < nrow(df)){
#remove duplicated SNPs
vcfR<-vcfR[!duplicated(paste(df$CHROM,df$POS)),]
#report to user
message(nrow(df) - length(unique(paste(df$CHROM,df$POS)))," duplicated SNPs removed from input vcf")
#regenerate df without duplicate inputs
df<-as.data.frame(vcfR@fix[,1:2])
}
length(unique(paste(df$CHROM,df$POS)))
#generate list of all unique chromosomes in alphabetical order
chroms<-levels(as.factor(df$CHROM))
#intialize empty df to hold filtering
keep.df<-data.frame()
#make progress bar
pb <- utils::txtProgressBar(min = 0, max = length(chroms), style = 3)
#begin tracker
pbtrack<-1
for (t in chroms){
#isolate the SNP positions on the given chromosome
fix.sub<-as.numeric(df$POS[df$CHROM == t])
#order the positions numerically
fix.sub<-fix.sub[order(fix.sub)]
#set the first position
prev<-fix.sub[1]
#initialize empty vector
k<-c()
#always keep first SNP on the chromosome
k[1]<-TRUE
#loop to decide whether to keep each following SNP
if (length(fix.sub) < 2){
#if chrom only has 1 SNP, do nothing
} else{
#else, use a for loop to determine which SNPs to keep that satisfy our distance criteria
for (i in 2:length(fix.sub)){
#store logical indicating whether this SNP is greater than j base pairs from the previous SNP
k[i]<- fix.sub[i] > prev+j
#if it is, then we keep this SNP, making it the new 'previous' for assessing the next point.
#If we don't keep the SNP, we don't update the closest point
if (fix.sub[i] > prev+j){
prev<-fix.sub[i]
}
#close for loop
}
#close else statement
}
#make a dataframe with the precise info for each SNP for this chromosome
chrom.df<-data.frame(CHROM=rep(t, times=length(fix.sub)), POS=fix.sub, keep=k)
#now we rbind in the information for this chromosome to the overall df
keep.df<-rbind(keep.df,chrom.df)
#empty df for this chrom to prepare for the next one
chrom.df<-NULL
#update progress bar
utils::setTxtProgressBar(pb, pbtrack)
#update tracker
pbtrack<-pbtrack+1
} #close for loop, start over on next chromosome
#close progress bar
close(pb)
#order the dataframe to match the order of the input vcf file
#remove scientific notation
keep.df$POS<-format(keep.df$POS,scientific = FALSE)
df$POS<-format(df$POS,scientific = FALSE)
#make sure class matches between the columns you're trying to merge
keep.df$POS<-as.numeric(as.character(keep.df$POS))
df$POS<-as.numeric(as.character(df$POS))
#make sure class matches between the columns you're trying to merge
keep.df$CHROM<-as.character(keep.df$CHROM)
df$CHROM<-as.character(df$CHROM)
#add tracking column
df$id<-c(1:nrow(df))
#merge
order.df<-merge(keep.df,df)
#order based on tracking column
order.df<-order.df[order(order.df$id),]
if (sum(is.na(order.df)) > .5){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
#write a test to catch if this internal dataset is not able to merge correctly
if (order.df$id != c(1:nrow(df))){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
View(order.df)
#write a test to catch if this internal dataset is not able to merge correctly
if (sum(order.df$id != c(1:nrow(df))) > .5){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
pkgdown::build_site()
pkgdown::build_home()
pkgdown::build_home()
rhub::check_for_cran()
pkgdown::build_home()
rhub::check_for_cran()
rhub::check_for_cran()
pkgdown::build_home()
pkgdown::build_home()
vcfR<-read.vcfR("~/Downloads/hippo.wgs/chr.18.subset.recode.vcf.gz")
j=100
#generate dataframe containing information for chromosome and bp locality of each SNP
df<-as.data.frame(vcfR@fix[,1:2])
#write test to identify and remove duplicated SNPs in input vcf
if (length(unique(paste(df$CHROM,df$POS))) < nrow(df)){
#remove duplicated SNPs
vcfR<-vcfR[!duplicated(paste(df$CHROM,df$POS)),]
#report to user
message(nrow(df) - length(unique(paste(df$CHROM,df$POS)))," duplicated SNPs removed from input vcf")
#regenerate df without duplicate inputs
df<-as.data.frame(vcfR@fix[,1:2])
}
#generate list of all unique chromosomes in alphabetical order
chroms<-levels(as.factor(df$CHROM))
#intialize empty df to hold filtering
keep.df<-data.frame()
#make progress bar
pb <- utils::txtProgressBar(min = 0, max = length(chroms), style = 3)
#begin tracker
pbtrack<-1
#loop over each chromosome
#for t in vector containing the name of each chromosome
for (t in chroms){
#isolate the SNP positions on the given chromosome
fix.sub<-as.numeric(df$POS[df$CHROM == t])
#order the positions numerically
fix.sub<-fix.sub[order(fix.sub)]
#set the first position
prev<-fix.sub[1]
#initialize empty vector
k<-c()
#always keep first SNP on the chromosome
k[1]<-TRUE
#loop to decide whether to keep each following SNP
if (length(fix.sub) < 2){
#if chrom only has 1 SNP, do nothing
} else{
#else, use a for loop to determine which SNPs to keep that satisfy our distance criteria
for (i in 2:length(fix.sub)){
#store logical indicating whether this SNP is greater than j base pairs from the previous SNP
k[i]<- fix.sub[i] > prev+j
#if it is, then we keep this SNP, making it the new 'previous' for assessing the next point.
#If we don't keep the SNP, we don't update the closest point
if (fix.sub[i] > prev+j){
prev<-fix.sub[i]
}
#close for loop
}
#close else statement
}
#make a dataframe with the precise info for each SNP for this chromosome
chrom.df<-data.frame(CHROM=rep(t, times=length(fix.sub)), POS=fix.sub, keep=k)
#now we rbind in the information for this chromosome to the overall df
keep.df<-rbind(keep.df,chrom.df)
#empty df for this chrom to prepare for the next one
chrom.df<-NULL
#update progress bar
utils::setTxtProgressBar(pb, pbtrack)
#update tracker
pbtrack<-pbtrack+1
} #close for loop, start over on next chromosome
#close progress bar
close(pb)
#order the dataframe to match the order of the input vcf file
#remove scientific notation
keep.df$POS<-format(keep.df$POS,scientific = FALSE)
df$POS<-format(df$POS,scientific = FALSE)
#make sure class matches between the columns you're trying to merge
keep.df$POS<-as.numeric(as.character(keep.df$POS))
df$POS<-as.numeric(as.character(df$POS))
#make sure class matches between the columns you're trying to merge
keep.df$CHROM<-as.character(keep.df$CHROM)
df$CHROM<-as.character(df$CHROM)
#add tracking column
df$id<-c(1:nrow(df))
#merge
order.df<-merge(keep.df,df)
#order based on tracking column
order.df<-order.df[order(order.df$id),]
View(order.df)
#write a test to catch if this internal dataset is not able to merge correctly
if (sum(is.na(order.df)) > .5){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
#write a test to catch if this internal dataset is not able to merge correctly
if (sum(order.df$id != c(1:nrow(df))) > .5){
stop("internal error with the merge function. Please email a copy of your input vcf to devonderaad@gmail.com for a bug fix")
}
ad.matrix<- vcfR::extract.gt(vcfR, element='AD')
as.numeric(gsub(".*,[^,]*,([^,]+).*", "\\1", c(9,98,99,0)))
as.numeric(gsub(".*,[^,]*,([^,]+).*", "\\1", c(9,98,99,0)))
strsplit(c(9,98,99,0), split = ",")
strsplit("9,98,99,0", split = ",")
strsplit("9,98,99,0", split = ",")[3]
dim(strsplit("9,98,99,0", split = ","))
dim(strsplit("9,98,99,0", split = ","))[[3]]
x<-strsplit("9,98,99,0", split = ",")
View(x)
x[[1]]
x[[1]][3]
strsplit("9,98,99,0", split = ",")[[1]][3]
#' allele balance in our data (for real loci) should be close to 0.5".
#'
#' @param vcfR a vcfR object
#' @param min.ratio minumum allele ratio for a called het
#' @param max.ratio maximum allele ratio for a called het
#' @return An identical vcfR object, except that genotypes failing the allele balance
#' filter have been converted to 'NA'.
#' @examples
#' filter_allele_balance(vcfR = SNPfiltR::vcfR.example)
#' @export
filter_allele_balance <- function(vcfR,
min.ratio=NULL,
max.ratio=NULL){
#if specified vcfR is not class 'vcfR', fail gracefully
if (class(vcfR) != "vcfR"){
stop("specified vcfR object must be of class 'vcfR'")
}
#set default parameter for minimum allele ratio for a het call (.25)
if(is.null(min.ratio)){
min.ratio=.25
}
#set default parameter for maximum allele ratio for a het call (.75)
if(is.null(max.ratio)){
max.ratio=.75
}
#if these ratios have been specified by the user, leave them alone
#extract allele depth from the vcf
#if allele depth is specified as 'AD', extract matrix
ad.matrix<- vcfR::extract.gt(vcfR, element='AD')
#write a test to identify how allele depth is specified, or not specified
if (length(grep("AD",vcfR@gt[,1])) > 0.5){
#if allele depth is specified as 'AD', extract matrix
ad.matrix<- vcfR::extract.gt(vcfR, element='AD')
}else if(length(grep("CATG",vcfR@gt[,1])) > 0.5){
#print warning that this will be slow
print("Warning, allele depth encoded only as raw CATG counts, must first index out relevant allele depths, which is time consuming")
#if allele depth is specified as 'CATG', extract matrix of 'CATG' values
full.matrix<- vcfR::extract.gt(vcfR, element='CATG')
#open empty matrix to hold relevant AD info same size as full.matrix
ad.matrix<-matrix(, nrow = nrow(full.matrix), ncol = ncol(full.matrix))
#extract only REF and ALT allele depth values
for (i in 1:nrow(full.matrix)){
#convert reference allele to indexing tool, C > 1, A > 2, T > 3, G > 4
k<-as.numeric(gsub("G","4",gsub("T","3",gsub("A","2",gsub("C","1",as.data.frame(vcfR@fix)$REF[i])))))
#convert ALT allele to indexing tool, C > 1, A > 2, T > 3, G > 4
l<-as.numeric(gsub("G","4",gsub("T","3",gsub("A","2",gsub("C","1",as.data.frame(vcfR@fix)$ALT[i])))))
#extract the REF and ALT depths for each genotype and save them as a single vector, w/ values separated by a comma. Write that vector to the new matrix
ad.matrix[i,]<-sapply(lapply(strsplit(full.matrix[i,],","), '[', c(k,l)), paste0, collapse=",")
}
print("CATG format converted to REF,ALT allele depth")
}else{
stop("allele depth is not specified in input vcf in 'AD' or 'CATG' format, therefore allele balance cannot be calculated")
}
#extract GT from the vcf
gt.matrix<- vcfR::extract.gt(vcfR, element='GT')
#mask ad matrix to include only called hets from gt matrix
ad.matrix[gt.matrix != "0/1" & gt.matrix != "1/0"]<-NA
#split allele 1 depth from allele 2 depth
al1<-structure(as.numeric(gsub(",.*", "", ad.matrix)), dim=dim(ad.matrix))
al2<-structure(as.numeric(gsub(".*,", "", ad.matrix)), dim=dim(ad.matrix))
#calculate AB for each sample
al.bal<-al1/(al1 + al2)
#calculate logical storing whether each het genotype passes the filter
AB<-al1/(al1 + al2) > max.ratio | al1/(al1 + al2) < min.ratio
#calculate percent of het genotypes failing the filter
p<-round(sum(AB, na.rm = TRUE) / sum(is.na(AB) == FALSE)*100, 2)
#calculate overall percentage of genotypes failing the filter
j<-round(sum(AB, na.rm = TRUE) / sum(is.na(gt.matrix) == FALSE)*100, 2)
#print to user
message(p,"% of het genotypes (",j,"% of all genotypes) fall outside of ",min.ratio," - ",max.ratio, " allele balance ratio and were converted to NA")
#convert failing genotypes to NA
vcfR@gt[,-1][AB]<-NA
#make histogram of allele balance at all het genotypes
graphics::hist(al.bal,
xlim = c(0,1),
ylab = "number of genotypes",
xlab = "Allele balance",
main ="allele balance distribution")
graphics::abline(v=c(min.ratio,max.ratio),
col="red")
#return vcfR
return(vcfR)
#close function
}
